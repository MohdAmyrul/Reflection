üß† What I Learned
- I gained foundational knowledge of how a computer functions at the hardware level‚Äîfrom binary number systems and logic gates to the intricacies of processor architecture and control units.
- Through assembly programming, I learned how to work close to the metal‚Äîdirectly interacting with CPU registers and memory while constructing low-level arithmetic and control operations.
- The breakdown of instruction cycles, pipelining, and memory hierarchy offered a clear picture of how efficiency is engineered inside processors, and how latency, bandwidth, and throughput are optimized.

‚öôÔ∏è Skills I Acquired
- Hardware-level reasoning: I can now interpret and design block diagrams representing data paths, control signals, and system cycles.
- Assembly programming proficiency: Writing efficient, logical code that manipulates registers and handles branching.
- Debugging mindset: I've developed precision in tracing operations step by step, which improves my ability to troubleshoot complex system behaviors.
- Conceptual agility: Moving fluidly between high-level software logic and low-level hardware implementation.

üîß Challenges and Breakthroughs
- One of the toughest parts was mastering low-level bit manipulation and addressing modes. It required thinking in binary and hex, something I initially found abstract but came to appreciate as the DNA of computing.
- Debugging early assembly code taught me patience and methodical thinking. Every logical misstep had a visible effect, which made me more disciplined in analyzing output behavior.

üå± Personal Reflection
What I appreciate most about this course is how it made computing intellectually tangible. There‚Äôs something deeply rewarding about understanding the logic behind a CPU's decision-making process‚Äîhow instructions move through fetch-decode-execute stages, and how every operation is grounded in electrical states.
This subject also built a strong foundation for my future interests in embedded systems, IoT edge devices, and hardware-aware AI algorithms. As I continue to explore those intersections, I‚Äôll carry this systems-level thinking with me‚Äîbecause architecture isn‚Äôt just about how things work, it‚Äôs about why they work the way they do.
